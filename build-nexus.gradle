/*
 * Nexus Repository Integration
 */

allprojects {
	apply plugin: "net.saliman.properties"
	apply plugin: "nu.studer.credentials"

	/* We accept crypted credentials via "nu.studer.credentials" or plain
	 * credentials via gradle-local.properties.
	 */
	ext.registryUsername = credentials.user ?: project.properties['nexus.username']
	ext.registryPassword = credentials.password ?: project.properties['nexus.password']

	repositories {
		mavenLocal()
		mavenCentral()

		String publicURL = project.properties['nexus.public.url']
		String releasesURL = project.properties['nexus.releases.url']
		String snapshotsURL = project.properties['nexus.snapshots.url']

		if (snapshotsURL) {
			maven {
				credentials {
					username project.properties['registryUsername']
					password project.properties['registryPassword']
				}
				url snapshotsURL
			}
		}

		if (releasesURL) {
			maven {
				credentials {
					username project.properties['registryUsername']
					password project.properties['registryPassword']
				}
				url releasesURL
			}
		}

		if (publicURL) {
			maven {
				credentials {
					username project.properties['registryUsername']
					password project.properties['registryPassword']
				}
				url publicURL
			}
		}
	}
}

/************************
 * RELEASE vs SNAPSHOTS *
 ************************/

apply plugin: "org.ajoberstar.grgit"

if (grgit != null) {
	logger.debug("Git ${grgit.branch.current().name}")

	ext.gitClone = true
	ext.gitBranchName = grgit.branch.current().name

	if (ext.gitBranchName.startsWith("release")) {
		ext.gitSnapshotsBranch = false
		ext.registrySuffix = ""
	}
	else if (ext.gitBranchName.startsWith("development")) {
		ext.gitSnapshotsBranch = true
		ext.registrySuffix = "-SNAPSHOT"
	}
	else if ("master".equals(gitBranchName)) {
		ext.gitSnapshotsBranch = true
		ext.registrySuffix = "-SNAPSHOT"
	}
	else {
		ext.gitSnapshotsBranch = true

		def issueId = gitBranchName =~ /^(\d+)/

		if (issueId.size() > 0) {
			ext.gitIssueId = issueId[0][1]
			ext.registrySuffix = "-${gitIssueId}-SNAPSHOT"
		}
		else if ("HEAD".equals(gitBranchName)) {
			def lastTag = grgit.describe()
			println "Git lastTag ${lastTag}"

			if (lastTag.startsWith("rel_") || lastTag.startsWith("MP_v")) {
				ext.gitSnapshotsBranch = false
				ext.registrySuffix = ""
			}
			else {
				ext.registrySuffix = "-SNAPSHOT"
			}
		}
		else {
			//throw new GradleException("Unsupported branch name ${gitBranchName}. Manage it!!")
			println ""
			println "WARNING:"
			println "WARNING: Unsupported branch name ${gitBranchName}. Manage it!!"
			println "WARNING:"
			println ""

			ext.gitSnapshotsBranch = true
			ext.registrySuffix = "-SNAPSHOT"
		}
	}

	//println "${gitSnapshotsBranch} ${registrySuffix}"
	logger.debug("${gitSnapshotsBranch} ${registrySuffix}")
}
else {
	println "No Git"

	ext.gitClone = false

	if (project.properties['nexus.release.mode'] == "true") {
		ext.registrySuffix = ""
	}
	else {
		ext.registrySuffix = "-SNAPSHOT"
	}
}

/*************************
 * TRACK CHANGED MODULES *
 *************************/

// Conterra' path dei moduli che hanno subito cambiamenti
Set changedProjects = []

ext.changesMode = false;

def changesModeEnabled = Boolean.valueOf(project.properties["changes.mode.enabled"])

if (changesModeEnabled && grgit != null && project.properties['gitSnapshotsBranch'] == true) {
	println "Git Branch ${grgit.branch.current().name}"

	def head = grgit.head();
	logger.debug("KK head=${head}")

	// Identifico l'eventuale tag di release piu' recente raggiungibile
	def describeTag = grgit.describe(longDescr: true, match: ["rel_*"])

	if (describeTag == null) {
		println "No releases found"
	}
	else {
		ext.changesMode = true;
		
		File smcChangesBarrier = new File(rootDir, ".smc_changes_barrier")

		if (smcChangesBarrier.exists()) {
			def content = smcChangesBarrier as String[]

			//println "content=[${content}]"
			//println "tag=[${describeTag}]"
			if (content.length > 0 && describeTag.startsWith(content[0])) {
				ext.changesMode = false;
			}
		}
	}

	if (ext.changesMode) {

		def collectChangedPath = {
			def p = "/" + it.toLowerCase()
			def v = false

			if (p.startsWith("/modules/")) {
				if (p.equals("/modules/build.gradle")) {
					v = false
				}
				else if (p.endsWith("/bnd.bnd")) {
					v = true
					changedProjects.add(p.minus("/bnd.bnd").replaceAll("/", ":"))
				}
				else if (p.endsWith("build.gradle")) {
					v = true
					changedProjects.add(p.minus("/build.gradle").replaceAll("/", ":"))
				}
				else if (p.contains("/src/")) {
					v = true
					changedProjects.add(p.minus(~/\/src\/.*$/).replaceAll("/", ":"))
				}

				if (v && ext.verboseMode) {
					println p
				}
			}
		}
		
		// Recupero i cambiamenti locali (non commitati)
		def status = grgit.status();

		status.staged.allChanges.each { path ->
			collectChangedPath(path);
		}
		status.unstaged.allChanges.each { path ->
			collectChangedPath(path);
		}

		// Ottengo l'oggetto Tag per averne il commit
		def lastReleaseTag = grgit.resolve.toTag(describeTag.minus(~/-\d+-\w+$/))

		println "Last ReleaseTag ${lastReleaseTag.getName()} : ${lastReleaseTag.shortMessage} : ${lastReleaseTag.dateTime} : ${lastReleaseTag.commit.id}"

		// Recupero i commit successivi il tag
		def commits = grgit.log {
			range(lastReleaseTag.commit, head)
		}

		commits.each{c ->
			if (ext.verboseMode) {
				println "${c.id} : ${c.abbreviatedId} : ${c.shortMessage}"
			}

			grgit.show(commit: c).each{ rev ->
				rev.getAllChanges().each { path ->
					collectChangedPath(path);
				}
			}
		}
	}
}

ext.changedProjects = changedProjects.sort(false)

if (ext.changesMode) {
	println "Modules with changes:"
	ext.changedProjects.each { println "  ${it}" }
	println ""
}

println "** changesMode = ${changesMode}"

